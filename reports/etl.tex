\section{Quy trình ETL và tiền xử lý dữ liệu}

\subsection{Tổng quan về quy trình ETL}

ETL (Extract, Transform, Load) là quy trình quan trọng để đưa dữ liệu từ nguồn vào kho dữ liệu. Quy trình ETL trong dự án này bao gồm ba giai đoạn chính:

\begin{enumerate}
    \item \textbf{Extract (Trích xuất)}: Đọc dữ liệu từ file CSV gốc.
    \item \textbf{Transform (Biến đổi)}: Làm sạch dữ liệu, feature engineering, tạo các bảng chiều và bảng sự kiện.
    \item \textbf{Load (Nạp)}: Xuất các bảng đã xử lý ra file CSV hoặc nạp vào cơ sở dữ liệu.
\end{enumerate}

\subsection{Giai đoạn 1: Extract - Trích xuất dữ liệu}

\subsubsection{Nguồn dữ liệu}

Dữ liệu được trích xuất từ file \texttt{Churn\_Modelling.csv} (tải từ Kaggle), chứa 10,000 bản ghi khách hàng.

\subsubsection{Công cụ sử dụng}

Sử dụng thư viện \texttt{pandas} của Python để đọc file CSV:

\begin{lstlisting}[style=python, caption=Đọc dữ liệu gốc]
import pandas as pd

# Doc file CSV
df = pd.read_csv('data/raw/Churn_Modelling.csv')

# Kiem tra kich thuoc
print(f"So luong ban ghi: {len(df)}")
print(f"So luong cot: {len(df.columns)}")
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
So luong ban ghi: 10000
So luong cot: 14
\end{verbatim}

\subsubsection{Kiểm tra chất lượng dữ liệu}

Sau khi đọc, cần kiểm tra:
\begin{itemize}
    \item Giá trị thiếu (missing values): Bộ dữ liệu này không có giá trị thiếu.
    \item Kiểu dữ liệu: Đảm bảo các cột có kiểu dữ liệu phù hợp.
    \item Giá trị trùng lặp: Kiểm tra CustomerId có bị trùng không.
\end{itemize}

\subsection{Giai đoạn 2: Transform - Biến đổi dữ liệu}

Đây là giai đoạn quan trọng nhất, bao gồm nhiều bước xử lý.

\subsubsection{Bước 1: Làm sạch dữ liệu}

\textbf{Loại bỏ các cột không cần thiết}:

Các cột \texttt{RowNumber}, \texttt{CustomerId}, và \texttt{Surname} không mang thông tin phân tích, được loại bỏ:

\begin{lstlisting}[style=python]
# Loai bo cac cot khong can thiet
df_clean = df.drop(['RowNumber', 'Surname'], axis=1)
\end{lstlisting}

\textbf{Lưu ý}: \texttt{CustomerId} được giữ lại để làm khóa tự nhiên trong dim\_customer.

\subsubsection{Bước 2: Feature Engineering}

Tạo các đặc trưng mới để phục vụ phân tích:

\textbf{a) Age Group (Nhóm tuổi)}:

\begin{lstlisting}[style=python]
def categorize_age(age):
    if age < 36:
        return 'Young'
    elif age < 56:
        return 'Middle-aged'
    else:
        return 'Senior'

df_clean['age_group'] = df_clean['Age'].apply(categorize_age)
\end{lstlisting}

\textbf{b) Income Group (Nhóm thu nhập)}:

\begin{lstlisting}[style=python]
def categorize_income(salary):
    if salary < 50000:
        return 'Low'
    elif salary < 100000:
        return 'Medium'
    else:
        return 'High'

df_clean['income_group'] = df_clean['EstimatedSalary'].apply(categorize_income)
\end{lstlisting}

\textbf{c) Snapshot Date}:

Vì dữ liệu là snapshot tại một thời điểm, ta tạo cột thời gian:

\begin{lstlisting}[style=python]
from datetime import datetime

# Gia su snapshot vao ngay 2025-01-01
df_clean['snapshot_date'] = datetime(2025, 1, 1)
\end{lstlisting}

\subsubsection{Bước 3: Xây dựng bảng chiều}

\textbf{a) dim\_customer}:

\begin{lstlisting}[style=python]
dim_customer = df_clean[['CustomerId', 'Age', 'Gender', 'Tenure']].copy()
dim_customer = dim_customer.drop_duplicates(subset=['CustomerId'])
dim_customer.reset_index(drop=True, inplace=True)
dim_customer['customer_key'] = dim_customer.index + 1
dim_customer.rename(columns={'CustomerId': 'customer_id', 
                             'Age': 'age',
                             'Gender': 'gender',
                             'Tenure': 'tenure'}, inplace=True)
\end{lstlisting}

\textbf{b) dim\_geo}:

\begin{lstlisting}[style=python]
dim_geo = df_clean[['Geography']].drop_duplicates()
dim_geo.reset_index(drop=True, inplace=True)
dim_geo['geo_key'] = dim_geo.index + 1
dim_geo.rename(columns={'Geography': 'country'}, inplace=True)
\end{lstlisting}

\textbf{c) dim\_time}:

\begin{lstlisting}[style=python]
dim_time = pd.DataFrame({
    'time_key': [1],
    'snapshot_date': [datetime(2025, 1, 1)],
    'year': [2025],
    'month': [1],
    'quarter': [1]
})
\end{lstlisting}

\textbf{d) dim\_segment}:

\begin{lstlisting}[style=python]
dim_segment = df_clean[['age_group', 'income_group']].drop_duplicates()
dim_segment.reset_index(drop=True, inplace=True)
dim_segment['segment_key'] = dim_segment.index + 1
\end{lstlisting}

\subsubsection{Bước 4: Xây dựng bảng sự kiện}

Bảng sự kiện được tạo bằng cách join dữ liệu gốc với các bảng chiều để lấy surrogate keys:

\begin{lstlisting}[style=python]
# Merge voi dim_customer de lay customer_key
fact = df_clean.merge(
    dim_customer[['customer_id', 'customer_key']], 
    left_on='CustomerId', 
    right_on='customer_id'
)

# Merge voi dim_geo de lay geo_key
fact = fact.merge(
    dim_geo[['country', 'geo_key']], 
    left_on='Geography', 
    right_on='country'
)

# Merge voi dim_segment de lay segment_key
fact = fact.merge(
    dim_segment[['age_group', 'income_group', 'segment_key']], 
    on=['age_group', 'income_group']
)

# Them time_key (tat ca deu la 1 vi chi co 1 snapshot)
fact['time_key'] = 1

# Chon cac cot cho fact table
fact_customer_status = fact[[
    'customer_key', 'time_key', 'geo_key', 'segment_key',
    'Balance', 'EstimatedSalary', 'NumOfProducts', 'CreditScore',
    'HasCrCard', 'IsActiveMember', 'Exited'
]]

# Doi ten cot
fact_customer_status.rename(columns={
    'Balance': 'balance',
    'EstimatedSalary': 'estimated_salary',
    'NumOfProducts': 'num_of_products',
    'CreditScore': 'credit_score',
    'HasCrCard': 'has_credit_card',
    'IsActiveMember': 'is_active_member',
    'Exited': 'churn_flag'
}, inplace=True)

# Them fact_key
fact_customer_status.reset_index(drop=True, inplace=True)
fact_customer_status['fact_key'] = fact_customer_status.index + 1
\end{lstlisting}

\subsection{Giai đoạn 3: Load - Nạp dữ liệu}

\subsubsection{Xuất ra file CSV}

Các bảng được xuất ra file CSV để dễ dàng kiểm tra và sử dụng:

\begin{lstlisting}[style=python]
# Xuat cac bang dimension
dim_customer.to_csv('data/processed/dim_customer.csv', index=False)
dim_geo.to_csv('data/processed/dim_geo.csv', index=False)
dim_time.to_csv('data/processed/dim_time.csv', index=False)
dim_segment.to_csv('data/processed/dim_segment.csv', index=False)

# Xuat bang fact
fact_customer_status.to_csv('data/processed/fact_customer_status.csv', index=False)

print("ETL hoan thanh! Cac file da duoc luu tai data/processed/")
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
ETL hoan thanh! Cac file da duoc luu tai data/processed/
 Saved: dim_customer.csv
 Saved: dim_geo.csv
 Saved: dim_time.csv
 Saved: dim_segment.csv
 Saved: fact_customer_status.csv
\end{verbatim}

\subsubsection{Nạp vào cơ sở dữ liệu (tùy chọn)}

Nếu muốn nạp vào PostgreSQL:

\begin{lstlisting}[style=python]
from sqlalchemy import create_engine

# Ket noi den database
engine = create_engine('postgresql://user:password@localhost:5432/bank_dwh')

# Nap du lieu
dim_customer.to_sql('dim_customer', engine, if_exists='replace', index=False)
dim_geo.to_sql('dim_geo', engine, if_exists='replace', index=False)
dim_time.to_sql('dim_time', engine, if_exists='replace', index=False)
dim_segment.to_sql('dim_segment', engine, if_exists='replace', index=False)
fact_customer_status.to_sql('fact_customer_status', engine, if_exists='replace', index=False)
\end{lstlisting}

\subsection{Tổng kết quy trình ETL}

\subsubsection{Kết quả đầu ra}

Sau khi chạy quy trình ETL, ta có:
\begin{itemize}
    \item \textbf{dim\_customer.csv}: 10,000 bản ghi (mỗi khách hàng một bản ghi)
    \item \textbf{dim\_geo.csv}: 3 bản ghi (France, Germany, Spain)
    \item \textbf{dim\_time.csv}: 1 bản ghi (snapshot date)
    \item \textbf{dim\_segment.csv}: 9 bản ghi (3 age groups × 3 income groups)
    \item \textbf{fact\_customer\_status.csv}: 10,000 bản ghi
\end{itemize}

\subsubsection{Ưu điểm của quy trình}

\begin{enumerate}
    \item \textbf{Tự động hóa}: Toàn bộ quy trình được viết bằng Python, có thể chạy lại bất cứ lúc nào.
    \item \textbf{Modular}: Mỗi bước được tách thành các function riêng, dễ bảo trì.
    \item \textbf{Reproducible}: Kết quả luôn nhất quán khi chạy lại với cùng dữ liệu đầu vào.
    \item \textbf{Scalable}: Có thể mở rộng để xử lý nhiều nguồn dữ liệu hoặc snapshot khác nhau.
\end{enumerate}

\subsubsection{Thách thức và giải pháp}

\begin{itemize}
    \item \textbf{Thách thức}: Đảm bảo tính toàn vẹn tham chiếu (referential integrity) giữa fact và dimension.
    \item \textbf{Giải pháp}: Sử dụng merge/join cẩn thận, kiểm tra không có NULL trong foreign keys.
    
    \item \textbf{Thách thức}: Xử lý dữ liệu mới trong tương lai (incremental load).
    \item \textbf{Giải pháp}: Có thể mở rộng bằng cách thêm logic kiểm tra dữ liệu đã tồn tại, chỉ insert bản ghi mới.
\end{itemize}
